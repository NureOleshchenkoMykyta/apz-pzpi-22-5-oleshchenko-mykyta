ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ  

Кафедра «Програмної інженерії»   

   

ЗВІТ    

З практичної роботи №1  

з дисципліни “Архітектура програмного забезпечення”  

на тему «Патерни проєктування»  

  

  

  

  

  

  

  

Виконав  	 ст. гр. ПЗПІ-22-5  	Олещенко Микита   

Перевірив  	 ст. викл. кафедри ПІ 	Сокорчук І. П.  

  

  

  

  

ХАРКІВ 2025  

  

  

  

  

ІСТОРІЯ ЗМІН  

  

№  

Дата  

Версія звіту  

Опис змін та виправлень  

1  

22.03.2025  

1.0  

Створено звіт з усіма розділами та додатками  

  

   

ЗАВДАННЯ  

  

У межах даної роботи необхідно обрати один із патернів проєктування (крім Singleton) та детально вивчити його призначення, принципи роботи та сфери застосування. Підготувати презентацію, яка міститиме теоретичний опис патерна та реальні приклади використання.  

  

ОПИС ВИКОНАНОЇ РОБОТИ  

  

У межах даної роботи було обрано патерн «Стан» як один із структурних патернів проєктування. Він дозволяє змінювати поведінку об'єкта залежно від його поточного стану без використання чисельних умовних конструкцій, та використання булевих прапорів.  

Патерн "Стан" використовується для керування змінами станів об'єкта під час його життєвого циклу. Його основні переваги включають зменшення умовних операторів, гнучкість та розширюваність, а також інкапсуляцію станів.  

Для перевірки роботи патерна було розроблено програмний код на TypeScript. Було реалізовано інтерфейс State, який дозволяє виводити інформацію залежно від збереженого у класі Context стану.  

Таким чином, у ході виконання роботи було досліджено патерн "Стан" та реалізовано його у програмному коді.  

       

4 ВИСНОВКИ  

У ході виконання цієї практичної роботи було детально вивчено патерн "State", його призначення, принципи роботи та відмінності від інших структурних патернів.   

Завдяки виконанню цієї роботи вдалося не лише поглибити знання про патерни проєктування, а й на практиці застосувати їх для вирішення реальних завдань у програмуванні.  

   

   

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

     ДОДАТОК А  

   Посилання на відеозапис доповіді та текст хронологічного опису доповіді  

  	Відеозапис доповіді на YouTube: https://youtu.be/kWDewyUiXBY  

Хронологічний опис відео:  

00:00 - Вступ  

00:36 - Що таке патерни проектування  

00:50 - Патерн State  

01:13 - Проблема, яку вирішує патерн  

01:33 - Як патерн вирішує проблему  

01:52 - Принцип використання - створення інтерфейсу  

02:40 - Принцип використання - створення класу "Context"  

03:03 - Принцип використання - реалізація станів  

03:34 - Принцип використання - результати запуску  

03:56 - Переваги патерну проектування State  

04:21 - Недоліки патерну проектування State  

04:38 - Висновки про користь патерну проектування State  

04:58 - Джерела інформації та закінчення відео  

  

  

  

  

  

  

  

  

  

  

ДОДАТОК Б  

Слайди презентації доповіді:  

  

 

Рисунок Б.1 – Титульний слайд  

 

Рисунок Б.2 – Що таке патерни проектування?  

 

Рисунок Б.3 – Патерн State  

 

Рисунок Б.4 – Яку проблему вирішує патерн State  

 

Рисунок Б.5 – Як патерн вирішує зазначену проблему  

 

Рисунок Б.6 – Створення інтерфейсу  

 

Рисунок Б.7 – Контекст  

 

Рисунок Б.8 - Реалізація станів  

  

 

Рисунок Б.9 - Запуск та результати  

 

Рисунок Б.10 - Переваги використання патерну   

 

Рисунок Б.11 - Недоліки використання патерну  

 

Рисунок Б.12 - Висновок  

 

Рисунок Б.13 - Джерела інформації  ДОДАТОК В  

Приклади програмного коду  

interface State {  

handle(): void;   

}   

4  

class Context {  

state: State;  

7  

constructor(initialState: State) {   

this.state = initialState;   

}   

11  

setState(state: State) {  

this.state = state;   

}   

15  

handle() {   

this.state.handle();  

}   

}   

20  

class ConcreteStateA implements State {   

handle() {   

console.log("ConcreteStateA");  24 	 	}   

25 }   

26  

class ConcreteStateB implements State {   

handle() {   

console.log("ConcreteStateB");   

}   

}   

32  

const context = new Context(new  

ConcreteStateA());  

context.handle();   

context.setState(new ConcreteStateB());   

context.handle();  
